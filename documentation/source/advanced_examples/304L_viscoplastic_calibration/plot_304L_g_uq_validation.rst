
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "advanced_examples/304L_viscoplastic_calibration/plot_304L_g_uq_validation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_advanced_examples_304L_viscoplastic_calibration_plot_304L_g_uq_validation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_advanced_examples_304L_viscoplastic_calibration_plot_304L_g_uq_validation.py:


304L stainless steel viscoplastic uncertainty quantification validation
------------------------------------------------------------------------
In this example, we will use MatCal's :class:`~matcal.core.parameter_studies.ParameterStudy`
to validate the estimated parameter uncertainty for the calibration. 
We do this by generating samples from the fitted covariance from 
:ref:`304L stainless steel viscoplastic calibration uncertainty quantification` and 
running the calibrated models with these samples. Then the 
model results are compared to the data to see how well the sampled parameter 
sets allow the models to represent the data uncertainty. 

.. note::
    Useful Documentation links:

    #. :ref:`Uniaxial Tension Models`
    #. :class:`~matcal.core.models.PythonModel`
    #. :func:`~matcal.core.parameter_studies.sample_multivariate_normal`

To begin, we reuse the data import, model preparation 
and objective specification for the tension model and rate 
models from :ref:`304L stainless steel viscoplastic calibration uncertainty quantification`.    

.. GENERATED FROM PYTHON SOURCE LINES 23-111

.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt
    from matcal import *

    plt.rc('text', usetex=True)
    plt.rc('font', family='serif')
    plt.rc('font', size=12)
    figsize = (4,3)

    tension_data = BatchDataImporter("ductile_failure_ASTME8_304L_data/*.dat", 
                                        file_type="csv", 
                                        fixed_states={"displacement_rate":2e-4, 
                                                      "temperature":530}).batch

    tension_data = scale_data_collection(tension_data, "engineering_stress", 1000)
    tension_data.remove_field("time")

    down_selected_data = DataCollection("down selected data")
    for state in tension_data.keys():
       for index, data in enumerate(tension_data[state]):
          down_selected_data.add(data[(data["engineering_stress"] > 36000) &
                                      (data["engineering_strain"] < 0.75)])

    rate_data_collection = matcal_load("rate_data.joblib")

    calibrated_params = matcal_load("voce_calibration_results.serialized")

    Y_0 = Parameter("Y_0", 20, 60, 
                    calibrated_params["Y_0"])
    A = Parameter("A", 100, 400, 
                  calibrated_params["A"])
    b = Parameter("b", 0, 3, 
                  calibrated_params["b"])
    C = Parameter("C", -3, -0.5, calibrated_params["C"])
    X = Parameter("X", 0.50, 1.75, 1.0)
    params = ParameterCollection("laplace params", Y_0, A, b, C)

    def JC_rate_dependence_model(Y_0, A, b, C, X, ref_strain_rate, rate, **kwargs):
        yield_stresses = np.atleast_1d(Y_0*X*(1+10**C*np.log(rate/ref_strain_rate)))
        yield_stresses[np.atleast_1d(rate) < ref_strain_rate] = Y_0
        return {"yield":yield_stresses}

    rate_model = PythonModel(JC_rate_dependence_model)
    rate_model.set_name("python_rate_model")

    material_name = "304L_viscoplastic"
    material_filename = "304L_viscoplastic_voce_hardening.inc"
    sierra_material = Material(material_name, material_filename,
                                "j2_plasticity")

    geo_params = {"extensometer_length": 0.75,
                   "gauge_length": 1.25, 
                   "gauge_radius": 0.125, 
                   "grip_radius": 0.25, 
                   "total_length": 4, 
                   "fillet_radius": 0.188,
                   "taper": 0.0015,
                   "necking_region":0.375,
                   "element_size": 0.01,
                   "mesh_method":3, 
                   "grip_contact_length":1}

    astme8_model = RoundUniaxialTensionModel(sierra_material, **geo_params)            
    astme8_model.add_boundary_condition_data(tension_data)       

    from site_matcal.sandia.computing_platforms import is_sandia_cluster, get_sandia_computing_platform
    from site_matcal.sandia.tests.utilities import MATCAL_WCID

    cores_per_node = 24
    if is_sandia_cluster():
        platform = get_sandia_computing_platform()
        cores_per_node = platform.processors_per_node

    astme8_model.set_number_of_cores(cores_per_node)
    if is_sandia_cluster():       
        astme8_model.run_in_queue(MATCAL_WCID, 1)
        astme8_model.continue_when_simulation_fails()
    astme8_model.set_allowable_load_drop_factor(0.45)
    astme8_model.set_name("ASTME8_tension_model")
    astme8_model.add_constants(ref_strain_rate=1e-5)

    X_calibrated = calibrated_params.pop("X")
    rate_model.add_constants(ref_strain_rate=1e-5, X=X_calibrated)
    astme8_model.add_constants(ref_strain_rate=1e-5)

    rate_objective = Objective("yield")
    astme8_objective = CurveBasedInterpolatedObjective("engineering_strain", "engineering_stress")








.. GENERATED FROM PYTHON SOURCE LINES 112-114

With the models, data, and objectives created, 
we import the :class:`~matcal.core.parameter_studies.LaplaceStudy` results from the previous step.

.. GENERATED FROM PYTHON SOURCE LINES 114-116

.. code-block:: Python

    laplace_covariance = matcal_load("laplace_study_covariance.joblib")








.. GENERATED FROM PYTHON SOURCE LINES 117-121

Next, we can sample
the calculated parameter distribution using 
:func:`~matcal.core.parameter_studies.sample_multivariate_normal` and evaluate 
the parameter uncertainty as desired. 

.. GENERATED FROM PYTHON SOURCE LINES 121-130

.. code-block:: Python

    num_samples=40
    mean = [calibrated_params["Y_0"], calibrated_params["A"],
             calibrated_params["b"], calibrated_params["C"]]
    uncertain_param_sets = sample_multivariate_normal(num_samples, 
                                                      mean,
                                                      laplace_covariance, 
                                                      12345, 
                                                      params.get_item_names())








.. GENERATED FROM PYTHON SOURCE LINES 131-132

We save the parameter samples to be used or plotted later.

.. GENERATED FROM PYTHON SOURCE LINES 132-134

.. code-block:: Python

    matcal_save("laplace_uq_validation_results.joblib", uncertain_param_sets)








.. GENERATED FROM PYTHON SOURCE LINES 135-138

Now we set up a study so we can 
visualize the results by pushing the samples back through the models.
We do so using a MatCal :class:`~matcal.core.parameter_studies.ParameterStudy`.

.. GENERATED FROM PYTHON SOURCE LINES 138-145

.. code-block:: Python

    param_study = ParameterStudy(Y_0, A, b, C)
    param_study.add_evaluation_set(astme8_model, astme8_objective, tension_data)
    param_study.add_evaluation_set(rate_model, rate_objective, rate_data_collection)
    param_study.set_core_limit(250)
    sampling_dir = "UQ_sampling_study"
    param_study.set_working_directory(sampling_dir, remove_existing=True)








.. GENERATED FROM PYTHON SOURCE LINES 146-159

Next, we add parameter evaluations for each of the samples. 
We do so by organizing the data using Python's
``zip`` function and then loop over the result
to add each parameter set sample to the study.

.. note::
   We add error catching to the addition of each parameter 
   evaluation. There is a chance that parameters could be 
   generated outside of our original bounds and we want the study to complete.
   If this error is caught, we will see it in the MatCal output 
   and know changes are needed. However, some results will still be output
   and can be of use.


.. GENERATED FROM PYTHON SOURCE LINES 159-172

.. code-block:: Python

    params_to_evaluate = zip(uncertain_param_sets["Y_0"], uncertain_param_sets["A"],
                             uncertain_param_sets["b"], uncertain_param_sets["C"])

    for Y_0, A_eval, b_eval, C_eval in params_to_evaluate:
        try:
          param_study.add_parameter_evaluation(Y_0=Y_0, A=A_eval, b=b_eval, C=C_eval)
          print(f"Running evaluation with Y_0={Y_0}, A={A_eval}, b={b_eval}, and "
              f"C={C_eval}.")
                               
        except ValueError:
           print(f"Skipping evaluation with Y={Y_0}, A={A_eval}, b={b_eval}, and "
                f"C={C_eval}. Parameters out of range.")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Running evaluation with Y_0=40.6479030193117, A=183.9050100285932, b=1.4581875297787004, and C=-1.9652111846619018.
    Running evaluation with Y_0=32.38564092088848, A=161.25511154399663, b=1.9924453208233182, and C=-1.3545136779880467.
    Running evaluation with Y_0=28.462109707202156, A=154.12798437374695, b=2.0250905064457263, and C=-0.9686058115329781.
    Running evaluation with Y_0=37.972442743510356, A=172.51627627154053, b=1.681150003131787, and C=-1.7319892115788569.
    Running evaluation with Y_0=28.806393892190496, A=146.4584353132245, b=2.2298990127215528, and C=-1.0009270492133513.
    Running evaluation with Y_0=29.435167940655848, A=136.8602458345028, b=2.3667745170980736, and C=-1.0028898423858863.
    Running evaluation with Y_0=35.270183657594345, A=162.2579167436363, b=1.933558499416257, and C=-1.5410723070228298.
    Running evaluation with Y_0=34.802666027649664, A=128.82035735722542, b=2.459364414317446, and C=-1.2821889431971365.
    Running evaluation with Y_0=33.82985646733944, A=176.74659698931202, b=1.6978578269508389, and C=-1.52090545120622.
    Running evaluation with Y_0=30.23933585773557, A=146.88144759247166, b=2.269817629196802, and C=-1.1507961182985795.
    Running evaluation with Y_0=32.65451655977355, A=154.29985451734714, b=2.0063300202916343, and C=-1.2656699026510216.
    Running evaluation with Y_0=31.543759140159697, A=161.2287342862786, b=1.9476844039314687, and C=-1.2545366744550348.
    Running evaluation with Y_0=33.81180301196123, A=158.59196455041484, b=1.949445314257842, and C=-1.379665561213952.
    Running evaluation with Y_0=33.528362989192566, A=150.2885848568732, b=2.0894680001542656, and C=-1.3233243914324555.
    Running evaluation with Y_0=29.410256946442328, A=155.05948626733925, b=2.0677660352711023, and C=-1.1060869029987046.
    Running evaluation with Y_0=35.08145230676739, A=160.741453053273, b=1.927408589422478, and C=-1.494040231825033.
    Running evaluation with Y_0=36.5347383208898, A=188.43177254475762, b=1.3635776106764284, and C=-1.6945848918256063.
    Running evaluation with Y_0=28.899662399654655, A=148.9064172398427, b=2.231469297849304, and C=-1.0775611924222812.
    Running evaluation with Y_0=34.994052085597694, A=159.36022030552246, b=1.977565382413577, and C=-1.5025564948994892.
    Running evaluation with Y_0=28.550785842620417, A=131.67242133156768, b=2.548041794930989, and C=-0.9599356664303449.
    Running evaluation with Y_0=32.89000734614142, A=163.81228567076178, b=1.9578872089920611, and C=-1.4093229458258851.
    Running evaluation with Y_0=35.43405261358471, A=169.57930796269366, b=1.795821565977895, and C=-1.569822756874545.
    Running evaluation with Y_0=33.904658690676186, A=146.35423395865354, b=2.1898354685786874, and C=-1.3402873779858269.
    Running evaluation with Y_0=33.59693972778456, A=143.86382895879055, b=2.2192085035131566, and C=-1.3003840067578007.
    Running evaluation with Y_0=33.16873450268536, A=166.18410301155484, b=1.877024301246788, and C=-1.4169785535296204.
    Running evaluation with Y_0=30.06829887462633, A=164.64529342200026, b=1.915278711152535, and C=-1.1905466835822052.
    Running evaluation with Y_0=30.471890403228148, A=165.1242219346902, b=1.8990560746540923, and C=-1.2186396648664122.
    Running evaluation with Y_0=32.30625283299175, A=156.33090011030504, b=1.960992882963163, and C=-1.2245524762627287.
    Running evaluation with Y_0=35.91526493780096, A=161.0882840801401, b=1.8820872747196424, and C=-1.5193312646436703.
    Running evaluation with Y_0=31.56038852436482, A=134.18213592298838, b=2.424503165508537, and C=-1.1380939149423275.
    Running evaluation with Y_0=36.05593333337907, A=173.76350980544856, b=1.6208088183802483, and C=-1.570683728788107.
    Running evaluation with Y_0=34.249303769494674, A=158.66457517067977, b=1.9595397711376061, and C=-1.4167401067360637.
    Running evaluation with Y_0=32.58604305224073, A=179.8677586597019, b=1.610855552712183, and C=-1.441827414170629.
    Running evaluation with Y_0=28.923804265635802, A=131.73214664054348, b=2.511009701680069, and C=-0.9793103449828884.
    Running evaluation with Y_0=31.643786984444, A=155.01382173058937, b=2.016574880748222, and C=-1.2051640898192315.
    Running evaluation with Y_0=36.92096851095651, A=172.9826994812395, b=1.7719895025423014, and C=-1.7386843459364394.
    Running evaluation with Y_0=32.07696277923578, A=137.7829598354818, b=2.3529461982743056, and C=-1.1808972896849304.
    Running evaluation with Y_0=34.793709512300296, A=184.78536383079697, b=1.4830082641561082, and C=-1.564257523627934.
    Running evaluation with Y_0=41.338698457841105, A=197.08845113747805, b=1.1610227773763884, and C=-2.021610024983963.
    Running evaluation with Y_0=35.09391064474853, A=174.94185264761896, b=1.64939840874107, and C=-1.5579004658145301.




.. GENERATED FROM PYTHON SOURCE LINES 173-176

Next, we launch the study and plot the results.
Once again, we use plotting functions from 
the previous examples to simplify the plotting processes.

.. GENERATED FROM PYTHON SOURCE LINES 176-225

.. code-block:: Python

    param_study_results = param_study.launch()
    astme_results = param_study_results.simulation_history[astme8_model.name]
    rate_results = param_study_results.simulation_history[rate_model.name]

    def compare_data_and_model(data, model_responses, indep_var, dep_var, 
                               plt_func=plt.plot, fig_label=""):
      fig = plt.figure(fig_label, constrained_layout=True, figsize=figsize)
      data.plot(indep_var, dep_var, plot_function=plt_func, ms=3, labels="data", 
                figure=fig, marker='o', linestyle='-', color="#bdbdbd", show=False)
      model_responses.plot(indep_var, dep_var, plot_function=plt_func,labels="models", 
                          figure=fig, linestyle='-', alpha=0.5)
      plt.xlabel("Engineering Strain (.)")
      plt.ylabel("Engineering Stress (psi)")
  

    compare_data_and_model(tension_data, astme_results, 
                           "engineering_strain", "engineering_stress", 
                           fig_label="tension model")

    def make_single_plot(data_collection, state, cur_idx, label, 
                         color, marker, **kwargs):
        data = data_collection[state][cur_idx]
        plt.semilogx(state["rate"], data["yield"][0],
                    marker=marker, label=label, color=color, 
                    **kwargs)

    def plot_dc_by_state(data_collection, label=None, color=None,
                         marker='o', best_index=None, only_label_first=False, **kwargs):
        for state in data_collection:
            if best_index is None:
                for idx, data in enumerate(data_collection[state]):
                    make_single_plot(data_collection, state, idx, label, 
                                     color, marker, **kwargs)
                    if ((color is not None and label is not None) or
                        only_label_first):
                        label = None
            else:
                make_single_plot(data_collection, state, best_index, label, 
                                 color, marker, **kwargs)
        plt.xlabel("engineering strain rate (1/s)")
        plt.ylabel("yield stress (ksi)")

    plt.figure(constrained_layout=True, figsize=figsize)
    plot_dc_by_state(rate_data_collection, label='experiments', 
                     color="k", markersize=10)
    plot_dc_by_state(rate_results, label='rate model', marker='x',
                     only_label_first=True)
    plt.legend()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /advanced_examples/304L_viscoplastic_calibration/images/sphx_glr_plot_304L_g_uq_validation_001.png
         :alt: plot 304L g uq validation
         :srcset: /advanced_examples/304L_viscoplastic_calibration/images/sphx_glr_plot_304L_g_uq_validation_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /advanced_examples/304L_viscoplastic_calibration/images/sphx_glr_plot_304L_g_uq_validation_002.png
         :alt: plot 304L g uq validation
         :srcset: /advanced_examples/304L_viscoplastic_calibration/images/sphx_glr_plot_304L_g_uq_validation_002.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.legend.Legend object at 0x15531ce09f10>



.. GENERATED FROM PYTHON SOURCE LINES 226-233

These figure show the model results from the 40 samples. 
For the tension model, the results appear to be good estimate of parameter 
uncertainty. The simulations encapsulate all data, without exhibiting 
too much variability. While the python rate dependence model results do not 
completely encapsulates all 
data, the results seem to be an adequate measure of overall uncertainty.
sphinx_gallery_thumbnail_number = 3


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (28 minutes 14.879 seconds)


.. _sphx_glr_download_advanced_examples_304L_viscoplastic_calibration_plot_304L_g_uq_validation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_304L_g_uq_validation.ipynb <plot_304L_g_uq_validation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_304L_g_uq_validation.py <plot_304L_g_uq_validation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_304L_g_uq_validation.zip <plot_304L_g_uq_validation.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
