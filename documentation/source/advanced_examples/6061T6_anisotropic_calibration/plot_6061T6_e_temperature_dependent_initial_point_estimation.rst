
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "advanced_examples/6061T6_anisotropic_calibration/plot_6061T6_e_temperature_dependent_initial_point_estimation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_advanced_examples_6061T6_anisotropic_calibration_plot_6061T6_e_temperature_dependent_initial_point_estimation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_advanced_examples_6061T6_anisotropic_calibration_plot_6061T6_e_temperature_dependent_initial_point_estimation.py:


6061T6 aluminum temperature calibration initial point estimation
----------------------------------------------------------------
In this example, we use MatFit to estimate the initial point for our 
material model temperature dependence functions. For more on the chosen 
model form see :ref:`6061T6 aluminum temperature dependent data analysis`.

.. note::
    Useful Documentation links:

    #. :ref:`Running MatFit`
    #. :class:`~matcal.core.data_importer.FileData`    

We begin by importing the data metrics that are required for MatFit
that were calculated in the previously referenced example.  
We will use the FileData tool to perform the import, so we import 
all of MatCal's tools. We also import MatFit tools, NumPy, matplotlib and glob before 
setting our preferred plotting defaults. 

.. GENERATED FROM PYTHON SOURCE LINES 20-32

.. code-block:: Python

    from matcal import *
    from matfit.models import Voce
    from matfit.fitting import MatFit

    from glob import glob
    import numpy as np
    import matplotlib.pyplot as plt

    plt.rc('text', usetex=True)
    plt.rc('font', family='serif')
    plt.rc('font', size=12)
    figsize = (4,3)







.. GENERATED FROM PYTHON SOURCE LINES 33-37

Since we want to keep these data identifiable by state, 
we write a function to perform the import, create the correct 
state from the filename and then add the data to a 
:class:`~matcal.core.data.DataCollection`.

.. GENERATED FROM PYTHON SOURCE LINES 37-48

.. code-block:: Python

    files = glob("*_matfit_metrics.csv")
    metrics_collection = DataCollection("matfit metrics")
    for filename in files:
        filename_split = filename.split("_")
        temperature = float(filename_split[1])
        direction = filename_split[3]
        new_state = State(f"temperature_{temperature:0.0f}_direction_{direction}", 
                          temperature=temperature, direction=direction)
        new_data = FileData(filename, state=new_state)
        metrics_collection.add(new_data)








.. GENERATED FROM PYTHON SOURCE LINES 49-72

With all the required data available, 
we can perform the MatFit initial point 
estimate. For MatFit, three steps 
are required. We must put the material 
data metrics into the correct data form, 
specify the parameters we want to 
calibrate and, finally, run the 
MatFit calibration. 
We perform each of these steps in separate 
functions as shown below. 
In the first function, we define the 
required material data metrics and 
properties that MatFit needs in a dictionary 
with the correct keys. 
The elastic constants will not be 
calibrated so they are specified 
as global constants. The remaining 
material data metrics are averaged 
from all the data for a given state. 
We are not concerned with uncertainty quantification 
at this point and the average should give 
an acceptable initial point for the full 
MatCal calibration to follow.

.. GENERATED FROM PYTHON SOURCE LINES 72-85

.. code-block:: Python

    youngs_modulus=10.3e6
    poissons_ratio=0.33
    def prepare_material_metrics(state):
        state_data = metrics_collection[state][0]
        material_metrics = {"ultimate_strength":np.average(state_data["ultimate_stress"]),
        "strain_at_ultimate":np.average(state_data["strain_at_ultimate_stress"]),
        "elongation":np.average(state_data["failure_strain"]),
        "yield_stress":np.average(state_data["yield_stress"]),
        "youngs_modulus":youngs_modulus,
        "poissons_ratio":poissons_ratio}
    
        return material_metrics








.. GENERATED FROM PYTHON SOURCE LINES 86-97

The next function defines the parameters 
we wish to calibrate using MatFit. Since we want to 
define temperature dependent functions for 
the yield and Voce hardening parameters, 
these are the three parameters for which we 
define MatFit parameters. 

.. note::
      The MatFit parameters are defined as dictionaries 
      where certain keywords are required 
      in order to be valid. See :cite:p:`matfit`.

.. GENERATED FROM PYTHON SOURCE LINES 97-110

.. code-block:: Python


    def prepare_matfit_parameters():
        hardening_modulus = dict(value=1.0, lower=0, upper=100.0e6, 
                                calibrate=True)
        exponential_coefficient=dict(value=15.0, lower=0.0, upper=300, 
                                    calibrate=True)
        yield_stress=dict(value=40e3, lower=0.0, upper=100e3, 
                                         calibrate=True)
        voce_parameters = dict(hardening_modulus=hardening_modulus,
                               exponential_coefficient=exponential_coefficient,
                               yield_stress=yield_stress)
        return voce_parameters








.. GENERATED FROM PYTHON SOURCE LINES 111-117

In the final function, 
We run MatFit for our Voce hardening model. 
First it calls the preceding two functions 
to prepare the material metrics and parameters. 
It then calibrates the Voce material model parameters
and returns the calibration results.

.. GENERATED FROM PYTHON SOURCE LINES 117-129

.. code-block:: Python

    def matfit_single_state(state):
        material_metrics = prepare_material_metrics(state)
        voce_parameters = prepare_matfit_parameters()
        voce_model = Voce(material_metrics, voce_parameters, name='Voce')
        MF = MatFit(voce_model)
        MF.fit(solver_settings=dict(method='trf'))
        solution = MF.get_solution()
        param_return_tuple = (solution["yield_stress"], 
                              solution["hardening_modulus"], 
                              solution["exponential_coefficient"])
        return param_return_tuple








.. GENERATED FROM PYTHON SOURCE LINES 130-142

We now are able to estimate the Voce hardening 
parameters and yield stresses for our material at 
the higher temperatures.  We will only use the 
data for the :math:`R_{11}` direction since
this direction's yield stress is the reference stress
for the material's Hill yield. Any small errors in the other 
directions' Voce hardening parameters will be corrected
when the full calibration is performed. 
We call the ``matfit_single_state`` function 
on each temperature for the :math:`R_{11}`
material direction and store the parameters for each 
temperature.

.. GENERATED FROM PYTHON SOURCE LINES 142-146

.. code-block:: Python

    y_672_ip, A_672_ip,  b_672_ip  = matfit_single_state("temperature_672_direction_R11")
    y_852_ip, A_852_ip,  b_852_ip  = matfit_single_state("temperature_852_direction_R11")
    y_1032_ip, A_1032_ip, b_1032_ip = matfit_single_state("temperature_1032_direction_R11")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    {'ultimate_strength': Data(42684.13851798), 'strain_at_ultimate': Data(0.05874515), 'elongation': Data(0.22790771), 'yield_stress': {'value': 40000.0, 'lower': 0.0, 'upper': 100000.0, 'calibrate': True}, 'youngs_modulus': 10300000.0, 'poissons_ratio': 0.33, 'hardening_modulus': {'value': 1.0, 'lower': 0, 'upper': 100000000.0, 'calibrate': True}, 'exponential_coefficient': {'value': 15.0, 'lower': 0.0, 'upper': 300, 'calibrate': True}}
    Missing parameter: hardening_model
    Using parameters default value: hardening_model | voce
    Missing parameter: density
    Using parameters default value: density | 1.0
    Missing parameter: yield_strength_offset
    Using parameters default value: yield_strength_offset | 0.002
    {'ultimate_strength': Data(33488.22266148), 'strain_at_ultimate': Data(0.01560803), 'elongation': Data(0.29146983), 'yield_stress': {'value': 40000.0, 'lower': 0.0, 'upper': 100000.0, 'calibrate': True}, 'youngs_modulus': 10300000.0, 'poissons_ratio': 0.33, 'hardening_modulus': {'value': 1.0, 'lower': 0, 'upper': 100000000.0, 'calibrate': True}, 'exponential_coefficient': {'value': 15.0, 'lower': 0.0, 'upper': 300, 'calibrate': True}}
    Missing parameter: hardening_model
    Using parameters default value: hardening_model | voce
    Missing parameter: density
    Using parameters default value: density | 1.0
    Missing parameter: yield_strength_offset
    Using parameters default value: yield_strength_offset | 0.002
    {'ultimate_strength': Data(13313.20735071), 'strain_at_ultimate': Data(0.02436546), 'elongation': Data(0.37004468), 'yield_stress': {'value': 40000.0, 'lower': 0.0, 'upper': 100000.0, 'calibrate': True}, 'youngs_modulus': 10300000.0, 'poissons_ratio': 0.33, 'hardening_modulus': {'value': 1.0, 'lower': 0, 'upper': 100000000.0, 'calibrate': True}, 'exponential_coefficient': {'value': 15.0, 'lower': 0.0, 'upper': 300, 'calibrate': True}}
    Missing parameter: hardening_model
    Using parameters default value: hardening_model | voce
    Missing parameter: density
    Using parameters default value: density | 1.0
    Missing parameter: yield_strength_offset
    Using parameters default value: yield_strength_offset | 0.002




.. GENERATED FROM PYTHON SOURCE LINES 147-154

The temperature dependence functions for the parameters 
will scale the room temperature values using a piecewise-linear 
function. 
As a result, we will need the room temperature (533 R)
parameter values, so we create a dictionary storing these parameters 
that resulted from the calibration in
:ref:`6061T6 aluminum calibration with anisotropic yield`.

.. GENERATED FROM PYTHON SOURCE LINES 154-156

.. code-block:: Python

    RT_calibrated_params = matcal_load("anisotropy_parameters.serialized")








.. GENERATED FROM PYTHON SOURCE LINES 157-166

Now we can use the MatFit data and the room temperature 
parameters to create our temperature dependent scaling functions for the 
yield stress and Voce hardening parameters.
For each parameter, we created an array that contains the room temperature 
calibration value and the MatFit estimates for the high temperature 
ordered from lowest temperature to highest. The array for each parameter
is normalized by the room temperature value for that parameter. 
The resulting array is the scaling value for each parameter at each 
temperature where data are available.

.. GENERATED FROM PYTHON SOURCE LINES 166-175

.. code-block:: Python

    yields = np.array([RT_calibrated_params["yield_stress"]*1e3, y_672_ip, y_852_ip, y_1032_ip])
    yield_scale_factors = yields/1000/RT_calibrated_params["yield_stress"]

    As = np.array([RT_calibrated_params["hardening"]*1e3, A_672_ip, A_852_ip, A_1032_ip])
    A_scale_factors=As/1000/RT_calibrated_params["hardening"]

    bs = np.array([RT_calibrated_params["b"], b_672_ip, b_852_ip, b_1032_ip])
    b_scale_factors=bs/RT_calibrated_params["b"]








.. GENERATED FROM PYTHON SOURCE LINES 176-178

We now plot the scaling functions to verify 
they meet our expectations. 

.. GENERATED FROM PYTHON SOURCE LINES 178-187

.. code-block:: Python

    plt.figure()
    plt.plot([533, 672, 852, 1032], yield_scale_factors, label='yield stress')
    plt.plot([533, 672, 852, 1032], A_scale_factors, label='Voce hardening modulus')
    plt.plot([533, 672, 852, 1032], b_scale_factors, label='Voce exponential coefficient')
    plt.ylabel("temperature scaling function (.)")
    plt.xlabel("temperature (R)")
    plt.legend()
    plt.show()




.. image-sg:: /advanced_examples/6061T6_anisotropic_calibration/images/sphx_glr_plot_6061T6_e_temperature_dependent_initial_point_estimation_001.png
   :alt: plot 6061T6 e temperature dependent initial point estimation
   :srcset: /advanced_examples/6061T6_anisotropic_calibration/images/sphx_glr_plot_6061T6_e_temperature_dependent_initial_point_estimation_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 188-201

In the plot, we can see that the yield and Voce saturation stress 
(referred to as hardening modulus in LAME and MatFit)
generally decrease wth increasing temperature as expected. 
The Voce exponential coefficient generally increases as the temperature 
increases. At 852 R, the exponential coefficient function increases significantly 
before reducing again at 1032 R. Ideally, this function should be 
monotonically increasing, however, this may not be an issue. 
We will move forward with this as our initial estimate for the functions 
and verify this does not cause undesirable behavior once the MatCal 
calibration is complete. We print the scale factors at each function 
below and write them to a file
so that they can be seen and imported into :ref:`6061T6 aluminum temperature dependent calibration`
as the initial point for the calibration.

.. GENERATED FROM PYTHON SOURCE LINES 201-213

.. code-block:: Python

    print(yield_scale_factors)
    print(A_scale_factors)
    print(b_scale_factors)
    output_params = {"Y_scale_factor_672":yield_scale_factors[1] ,
                     "Y_scale_factor_852":yield_scale_factors[2], 
                     "Y_scale_factor_1032":yield_scale_factors[3],
                     "A_scale_factor_672":A_scale_factors[1], 
                     "A_scale_factor_852":A_scale_factors[2], 
                     "A_scale_factor_1032":A_scale_factors[3],
                     "b_scale_factor_672":b_scale_factors[1], 
                     "b_scale_factor_852":b_scale_factors[2], 
                     "b_scale_factor_1032":b_scale_factors[3]}
    matcal_save("temperature_parameters_initial.serialized", output_params)



.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [1.         0.9266122  0.76412509 0.30380963]
    [1.         0.59786569 0.10482988 0.07727676]
    [1.         2.01872306 8.95459464 2.49730319]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.924 seconds)


.. _sphx_glr_download_advanced_examples_6061T6_anisotropic_calibration_plot_6061T6_e_temperature_dependent_initial_point_estimation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_6061T6_e_temperature_dependent_initial_point_estimation.ipynb <plot_6061T6_e_temperature_dependent_initial_point_estimation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_6061T6_e_temperature_dependent_initial_point_estimation.py <plot_6061T6_e_temperature_dependent_initial_point_estimation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_6061T6_e_temperature_dependent_initial_point_estimation.zip <plot_6061T6_e_temperature_dependent_initial_point_estimation.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
